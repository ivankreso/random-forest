

/* This is general random tree learning implementation that consists of the following classes:
   - tree, parms, loss, split, node
   */
struct Prediction {  
  Labels labels;
  Score score;
};
class Data {
  struct DataInfo {
    int image_id;
    int x, y;
  }
  GetData();
  GetLabel();
  std::map<int,SampleInfo> index_map_;
  DataType& operator[int example_num, int dim] {}

 private:
  std::vector<DataType> data_;
  std::vector<int> labels_;
};

class Loss {
 public:
  Eval(data, labels);   // Evaluates the (supervised) loss 
};

class LogLoss : public Loss {

};

class Split {
 public:
  sample(data, indices);    // Samples the split
}

struct Params {
 public:
  struct StopCriterion {};
  Params(Loss loss, Split split, StopCriterion stop_criterion); // Sets loss type, split type and defines stopping criterion for tree growing
 private:
  Loss  loss;
  Split split;
  // TODO: stopping criterion
};

class UnivariateHardSplit : public Split;

class Node {
 public:
  Node();
  bool Split();
  float GetLossReduction();
 private:
  std::vector<int> node_indices; 
  float                node_value;
  Split                node_split;
  float                split_loss_reduction;
  std::vector<Node>    children;
};

class Tree {
 public: 
  Tree();
  Tree(Data data, Params params); // Constructor that sets data (and optionally labels), loss, split, and tree building parameters
  Grow();                 // Grows the tree using the parameters
  Predict(Data data, Prediction prediction);  // Gives the label predictions for the data points
 private:
  Params params_;
  Node                   root;
  data_type              data;
  labels_type            labels;
  bool stop_growing(parms);   // Checks if the tree construction needs to be stopped
  priority_queue<node>   pq;  // Priority queue for the nodes, ordered by the loss decrease of already splitted nodes
};





